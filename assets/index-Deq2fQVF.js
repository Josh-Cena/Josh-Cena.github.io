import{u as n,j as e}from"./index-BGRydkNA.js";const r="/assets/index-1JaNeHTZ.png",h={description:"Advent of Code 2024 solutions and notes. Summary of my experience with the puzzles and the OCaml language.",title:"Advent of Code 2024 notes"};function a(s){const t={a:"a",code:"code",em:"em",h1:"h1",img:"img",p:"p",...n(),...s.components};return e.jsxs(e.Fragment,{children:[e.jsx(t.h1,{children:"Advent of Code 2024 notes"}),`
`,`
`,e.jsxs(t.p,{children:[e.jsx(t.img,{src:"https://img.shields.io/badge/OCaml-%23E98407.svg?style=for-the-badge&logo=ocaml&logoColor=white",alt:"OCaml"})," | ",e.jsx(t.a,{href:"https://adventofcode.com/2024",children:"Problem statements"})," | ",e.jsx(t.a,{href:"https://github.com/Josh-Cena/aoc2024",children:"Source code"})]}),`
`,e.jsxs("nav",{style:{width:"100%",display:"flex",justifyContent:"space-between"},children:[e.jsx("a",{href:"/notes/aoc/2023/",children:"← Previous year"}),e.jsx("a",{href:"/notes/aoc/",children:"Back to AoC index"}),e.jsx("a",{href:"/notes/aoc/2025/",children:"→ Next year"})]}),`
`,e.jsx("ul",{style:{display:"flex",gap:"0.5rem",flexWrap:"wrap",listStyle:"none",padding:0},children:Array.from({length:25},(o,i)=>i+1).map(o=>e.jsx("li",{style:{width:"1.5rem",textAlign:"center"},children:e.jsx("a",{href:`/notes/aoc/2024/${o}`,children:o})},o))}),`
`,e.jsxs(t.p,{children:["2024 was supposedly my fourth year doing AoC, but I actually did it retrospectively in 2025. I was completely occupied with final season and schoolwork in December. The spring of 2024, I took the infamous ",e.jsx(t.a,{href:"https://coursetable.com/worksheet?course-modal=202401-28082",children:"systems programming"})," class where I practiced Rust. Then in fall, I took a ",e.jsx(t.a,{href:"https://coursetable.com/worksheet?course-modal=202403-10132",children:"compilers"})," class entirely in OCaml and a ",e.jsx(t.a,{href:"https://coursetable.com/worksheet?course-modal=202403-10141",children:"software analysis and verification"})," class that was half-Haskell half-Rust. Later in spring 2025, I took a ",e.jsx(t.a,{href:"https://coursetable.com/worksheet?course-modal=202501-22580",children:"formal semantics"})," class in Rocq. My prowess with programming languages grew significantly, and I decided to try out the new hammer in my toolbox: OCaml."]}),`
`,e.jsxs(t.p,{children:["I thought OCaml would be as elegant and enjoyable as Haskell, but it turned out to be on the other side of the spectrum. I pretty much lamented everything that Haskell has but OCaml lacks, and equally detested everything that OCaml exclusively has. For example, I can't resist using ",e.jsx(t.code,{children:"while"}),", arrays, and loops because they make my brain feel at ease, which I had to later refactor into recursion. On the other hand, I really missed Haskell's powerful abstractions—what's an FP language without function composition, lazy evaluation, and immutable collections? OCaml's standard library is also extremely bare-bones, especially compared to Haskell's. It doesn't even have a polymorphic print function."]}),`
`,e.jsxs(t.p,{children:["I enjoyed this year's tributes to past years' themes, although I only have experience with half of them. I did expect more connection in the actual ",e.jsx(t.em,{children:"puzzle"})," though, like same input format or similar algorithms, but looks like the connection is only present in the first paragraph or two."]}),`
`,e.jsxs(t.p,{children:["Difficulty-wise, I think 2024 is tuned down from 2022 and 2023. Everything was pretty frictionless until ",e.jsx(t.a,{href:"/notes/aoc/2024/14/",children:"14"}),", whose part 2 I had to search on Reddit for hints. ",e.jsx(t.a,{href:"/notes/aoc/2024/17/",children:"17"})," took a good amount of my time, but I enjoyed these VM problems as always. I would consider ",e.jsx(t.a,{href:"/notes/aoc/2024/18/",children:"18"})," demanding some thought (I messed up part 2 initially with node allocation, which I had to debug for a while). ",e.jsx(t.a,{href:"/notes/aoc/2024/21/",children:"21"})," is ",e.jsx(t.em,{children:"by far"})," the hardest problem of the year, and perhaps even the hardest of all times. I was traveling when doing this, and I spent a night and a train ride solving it. ",e.jsx(t.a,{href:"/notes/aoc/2024/23/",children:"23"})," is only hard because I can't cheat with ",e.jsx(t.code,{children:"igraph"})," or ",e.jsx(t.code,{children:"networkx"})," (which I would have done if I chose R or Python). ",e.jsx(t.a,{href:"/notes/aoc/2024/24/",children:"24"})," wasn't particularly ",e.jsx(t.em,{children:"hard"}),' (if one knows the structure of an adder) but very tedious to code up. My initial solution was more of a "computer-',e.jsx(t.em,{children:"assisted"}),' solution" since it stops every time a swap is continued, and only restarts when the swap is hard-coded in the source code. My revised algorithm gets rid of this, but it still relies on mercy of the input.']}),`
`,e.jsx(t.p,{children:e.jsx(t.img,{src:r,alt:"landing page",width:1888,height:1490})})]})}function c(s={}){const{wrapper:t}={...n(),...s.components};return t?e.jsx(t,{...s,children:e.jsx(a,{...s})}):a(s)}export{c as default,h as frontMatter};
