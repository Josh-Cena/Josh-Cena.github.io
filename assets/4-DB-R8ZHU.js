import{u as i,j as s}from"./index-JVg7E-KF.js";import{F as r,a as c}from"./_components-4OamRaNd.js";const a={description:"Advent of Code 2019 - Day 4: Secure Container. Written in C++.",tags:["Brute force"],year:2019,day:4,title:"AoC 2019 D4: Secure Container"};function t(n){const e={annotation:"annotation",code:"code",h1:"h1",h2:"h2",math:"math",mfrac:"mfrac",mn:"mn",mo:"mo",mrow:"mrow",p:"p",semantics:"semantics",span:"span",...i(),...n.components};return s.jsxs(s.Fragment,{children:[s.jsx(e.h1,{children:"AoC 2019 D4: Secure Container"}),`
`,`
`,s.jsx(r,{frontMatter:a}),`
`,s.jsx(e.h2,{children:"Part 1"}),`
`,s.jsxs(e.p,{children:["Again, no tricks here. Even just exhausting all six-digit numbers (100000 to 999999) would just be a million iterations, which is manageable. The only optimization I actually implemented is that after enumerating a higher digit, the next digit must be at least that digit (to ensure non-decreasing order). There are only ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mo,{fence:"true",children:"("}),s.jsxs(e.mfrac,{linethickness:"0px",children:[s.jsxs(e.mrow,{children:[s.jsx(e.mn,{children:"9"}),s.jsx(e.mo,{children:"+"}),s.jsx(e.mn,{children:"6"}),s.jsx(e.mo,{children:"−"}),s.jsx(e.mn,{children:"1"})]}),s.jsx(e.mn,{children:"6"})]}),s.jsx(e.mo,{fence:"true",children:")"})]}),s.jsx(e.mo,{children:"="}),s.jsx(e.mn,{children:"3003"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\binom{9+6-1}{6}=3003"})]})})}),s.jsxs(e.span,{className:"katex-html","aria-hidden":"true",children:[s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1.2451em",verticalAlign:"-0.35em"}}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mopen delimcenter",style:{top:"0em"},children:s.jsx(e.span,{className:"delimsizing size1",children:"("})}),s.jsx(e.span,{className:"mfrac",children:s.jsxs(e.span,{className:"vlist-t vlist-t2",children:[s.jsxs(e.span,{className:"vlist-r",children:[s.jsxs(e.span,{className:"vlist",style:{height:"0.8951em"},children:[s.jsxs(e.span,{style:{top:"-2.355em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:s.jsx(e.span,{className:"mord mtight",children:"6"})})})]}),s.jsxs(e.span,{style:{top:"-3.144em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsxs(e.span,{className:"mord mtight",children:[s.jsx(e.span,{className:"mord mtight",children:"9"}),s.jsx(e.span,{className:"mbin mtight",children:"+"}),s.jsx(e.span,{className:"mord mtight",children:"6"}),s.jsx(e.span,{className:"mbin mtight",children:"−"}),s.jsx(e.span,{className:"mord mtight",children:"1"})]})})]})]}),s.jsx(e.span,{className:"vlist-s",children:"​"})]}),s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.345em"},children:s.jsx(e.span,{})})})]})}),s.jsx(e.span,{className:"mclose delimcenter",style:{top:"0em"},children:s.jsx(e.span,{className:"delimsizing size1",children:")"})})]}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.2778em"}}),s.jsx(e.span,{className:"mrel",children:"="}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"0.6444em"}}),s.jsx(e.span,{className:"mord",children:"3003"})]})]})]})," non-decreasing sequences using 9 digits, so this is very trivial already. Theoretically, I can also constrain the first digit based on the given range, but I didn't bother and just checked the range for each number."]}),`
`,s.jsxs(e.p,{children:["The code is just 6 nested loops, one for each digit. I check if there's at least one pair of equal adjacent digits, and that the number (",s.jsx(e.code,{children:"100000 * a + 10000 * b + 1000 * c + 100 * d + 10 * e + f"}),") is within the given range."]}),`
`,s.jsx(e.h2,{children:"Part 2"}),`
`,s.jsxs(e.p,{children:["The check is the same as before (",s.jsx(e.code,{children:"num[i] == num[i - 1]"}),"), but also check that ",s.jsx(e.code,{children:"num[i - 2] != num[i]"})," and ",s.jsx(e.code,{children:"num[i + 1] != num[i]"})," (with boundary checks)."]}),`
`,s.jsx(c,{frontMatter:a})]})}function h(n={}){const{wrapper:e}={...i(),...n.components};return e?s.jsx(e,{...n,children:s.jsx(t,{...n})}):t(n)}export{h as default,a as frontMatter};
