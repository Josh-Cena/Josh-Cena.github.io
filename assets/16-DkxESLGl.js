import{u as i,j as e}from"./index-DEJgW3cN.js";import{F as r,a as l}from"./_components-C_Mh6GSJ.js";const a={description:"Advent of Code 2019 - Day 16: Flawed Frequency Transmission. Written in C++.",tags:["Puzzle","Memoization"],year:2019,day:16,title:"AoC 2019 D16: Flawed Frequency Transmission"};function t(n){const s={annotation:"annotation",code:"code",h1:"h1",h2:"h2",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",...i(),...n.components};return e.jsxs(e.Fragment,{children:[e.jsx(s.h1,{children:"AoC 2019 D16: Flawed Frequency Transmission"}),`
`,`
`,e.jsx(r,{frontMatter:a}),`
`,e.jsx(s.h2,{children:"Part 1"}),`
`,e.jsxs(s.p,{children:["Not much to say here; just implement the algorithm as described. One useful observation is that we don't actually need to build the full pattern for each index ",e.jsx(s.code,{children:"i"}),". The pattern is just the base pattern ",e.jsx(s.code,{children:"[0, 1, 0, -1]"}),", with each value repeated ",e.jsx(s.code,{children:"i + 1"})," times. So as the ",e.jsx(s.code,{children:"j"})," index iterates through the input numbers, it also iterates through the pattern by jumping to the next value every ",e.jsx(s.code,{children:"i + 1"})," steps (starting from 1, since we are skipping the very first ",e.jsx(s.code,{children:"0"})," in the pattern)."]}),`
`,e.jsx(s.pre,{children:e.jsx(s.code,{className:"language-cpp",children:`int sum = 0;
int repeat_count = 0;
for (size_t j = 0; j < numbers.size(); j++) {
    sum += numbers[j] * base_pattern[((j + 1) / (i + 1)) % 4];
}
new_numbers[i] = std::abs(sum) % 10;
`})}),`
`,e.jsx(s.h2,{children:"Part 2"}),`
`,e.jsxs(s.p,{children:["There are 6,500,000 digits in the real input, and a naïve FFT is ",e.jsxs(s.span,{className:"katex",children:[e.jsx(s.span,{className:"katex-mathml",children:e.jsx(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:e.jsxs(s.semantics,{children:[e.jsxs(s.mrow,{children:[e.jsx(s.mi,{mathvariant:"script",children:"O"}),e.jsx(s.mo,{stretchy:"false",children:"("}),e.jsxs(s.msup,{children:[e.jsx(s.mi,{children:"n"}),e.jsx(s.mn,{children:"2"})]}),e.jsx(s.mo,{stretchy:"false",children:")"})]}),e.jsx(s.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(n^2)"})]})})}),e.jsx(s.span,{className:"katex-html","aria-hidden":"true",children:e.jsxs(s.span,{className:"base",children:[e.jsx(s.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),e.jsx(s.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),e.jsx(s.span,{className:"mopen",children:"("}),e.jsxs(s.span,{className:"mord",children:[e.jsx(s.span,{className:"mord mathnormal",children:"n"}),e.jsx(s.span,{className:"msupsub",children:e.jsx(s.span,{className:"vlist-t",children:e.jsx(s.span,{className:"vlist-r",children:e.jsx(s.span,{className:"vlist",style:{height:"0.8141em"},children:e.jsxs(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[e.jsx(s.span,{className:"pstrut",style:{height:"2.7em"}}),e.jsx(s.span,{className:"sizing reset-size6 size3 mtight",children:e.jsx(s.span,{className:"mord mtight",children:"2"})})]})})})})})]}),e.jsx(s.span,{className:"mclose",children:")"})]})})]}),", which is way too slow. However, notice that the message offset is quite large—it's in the second half of the signal. The pattern for ",e.jsx(s.code,{children:"nums[-1]"})," looks like ",e.jsx(s.code,{children:"[0, ..., 0, 1]"}),", and the pattern for ",e.jsx(s.code,{children:"nums[-2]"})," looks like ",e.jsx(s.code,{children:"[0, ..., 0, 1, 1]"}),", and so on, all the way to the middle of the signal. This means that for all indices ",e.jsx(s.code,{children:"i"})," greater than half the length of the signal, the new value is just the sum of all values from ",e.jsx(s.code,{children:"i"})," to the end of the signal, modulo 10. We can do this in ",e.jsxs(s.span,{className:"katex",children:[e.jsx(s.span,{className:"katex-mathml",children:e.jsx(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:e.jsxs(s.semantics,{children:[e.jsxs(s.mrow,{children:[e.jsx(s.mi,{mathvariant:"script",children:"O"}),e.jsx(s.mo,{stretchy:"false",children:"("}),e.jsx(s.mi,{children:"n"}),e.jsx(s.mo,{stretchy:"false",children:")"})]}),e.jsx(s.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(n)"})]})})}),e.jsx(s.span,{className:"katex-html","aria-hidden":"true",children:e.jsxs(s.span,{className:"base",children:[e.jsx(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),e.jsx(s.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),e.jsx(s.span,{className:"mopen",children:"("}),e.jsx(s.span,{className:"mord mathnormal",children:"n"}),e.jsx(s.span,{className:"mclose",children:")"})]})})]})," time per phase by iterating backwards and keeping a running sum:"]}),`
`,e.jsx(s.pre,{children:e.jsx(s.code,{className:"language-cpp",children:`std::vector<int> last_few(nums_len - offset);
for (int i = offset; i < nums_len; i++) {
    last_few[i - offset] = line[i % line.size()] - '0';
}
for (int phase = 0; phase < 100; phase++) {
    int sum = 0;
    for (int i = last_few.size() - 1; i >= 0; i--) {
        sum = (sum + last_few[i]) % 10;
        last_few[i] = sum;
    }
}
`})}),`
`,e.jsx(l,{frontMatter:a})]})}function m(n={}){const{wrapper:s}={...i(),...n.components};return s?e.jsx(s,{...n,children:e.jsx(t,{...n})}):t(n)}export{m as default,a as frontMatter};
