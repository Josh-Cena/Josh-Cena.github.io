import{u as i,j as e}from"./index-CkPAr150.js";import{Y as a}from"./_components-CwXKVufl.js";const s="/assets/index-B5BUi1v6.png",h={description:"Advent of Code 2019 solutions and notes. Summary of my experience with the puzzles and the C++ language.",title:"Advent of Code 2019 notes"};function o(n){const t={a:"a",code:"code",em:"em",h1:"h1",img:"img",p:"p",...i(),...n.components};return e.jsxs(e.Fragment,{children:[e.jsx(t.h1,{children:"Advent of Code 2019 notes"}),`
`,`
`,`
`,e.jsx(a,{year:2019}),`
`,e.jsxs(t.p,{children:["I started AoC in 2021, so 2019 and 2020 were done retrospectively in 2025. I started programming in 2017 with Arduino and Lego, but I didn't ",e.jsx(t.em,{children:"seriously"})," learn programming until the summer of 2019, so I decided that I won't go further back than 2019 to respect history. By the end of 2019, I knew 4 languages, three of which pretty much ",e.jsx(t.em,{children:"only"})," learned in 2019: C/C++ (from Arduino & coding competitions), Java (from AP CS & some personal projects), Python (I was starting with mathematical modeling), and JavaScript (I was starting with web dev). The 2019 me would probably have chosen Java since I was most fluent in that at the time, but since I'm doing this in 2025 anyway, I decided to go with C++ since Java is a pain to run in VS Code, and also I'd really hate to ever be associated with Java again. So, first language I learned, first AoC—C++ it is."]}),`
`,e.jsxs(t.p,{children:["Before I started, I already heard many good things about this year. Intcode did turn out to be a lot of fun—these problems would not have been possible without it. Code sharing was one of the weak points of C++ though; the 2019 me would probably have suffered because I didn't know about ",e.jsx(t.code,{children:"make"})," back then, but now with some makefile incantation I was able to implement a ",e.jsx(t.code,{children:"make run"})," command that runs the code in one line while splitting out Intcode into a separate file."]}),`
`,e.jsxs(t.p,{children:["C++ turned out to be surprisingly versatile while maintaining okay performance. There are surprisingly few languages that get stdlib right, although C++ does it with terrible verbosity—I've had enough writing ",e.jsx(t.code,{children:"std::unordered_map<std::pair<int, int>, std::string>"}),"!! Its string manipulation was pretty limited though, lacking things like ",e.jsx(t.code,{children:"split()"})," and ",e.jsx(t.code,{children:"replace()"}),". I also didn't particularly optimize my code, otherwise I would have cut back on my use of ",e.jsx(t.code,{children:"std::pair"}),", ",e.jsx(t.code,{children:"std::tuple"}),", etc. which do a lot of allocation and copying."]}),`
`,e.jsxs(t.p,{children:["Difficulty-wise, I find this year harder than average. Problems I've had non-trivial struggles with include: ",e.jsx(t.a,{href:"/notes/aoc/2019/13/",children:"13"}),", ",e.jsx(t.a,{href:"/notes/aoc/2019/16/",children:"16"}),", ",e.jsx(t.a,{href:"/notes/aoc/2019/17/",children:"17"}),", ",e.jsx(t.a,{href:"/notes/aoc/2019/18/",children:"18"}),", ",e.jsx(t.a,{href:"/notes/aoc/2019/19/",children:"19"}),", and ",e.jsx(t.a,{href:"/notes/aoc/2019/21/",children:"21"}),". ",e.jsx(t.a,{href:"/notes/aoc/2019/22/",children:"22"})," was tricky but the input magnitude forced the optimization (many problems appear doable within one minute or two and it's hard to tell if you are supposed to do better). ",e.jsx(t.a,{href:"/notes/aoc/2019/25/",children:"25"})," was tedious, but I wouldn't consider it hard."]}),`
`,e.jsx(t.p,{children:e.jsx(t.img,{src:s,alt:"landing page",width:1888,height:1398})})]})}function c(n={}){const{wrapper:t}={...i(),...n.components};return t?e.jsx(t,{...n,children:e.jsx(o,{...n})}):o(n)}export{c as default,h as frontMatter};
