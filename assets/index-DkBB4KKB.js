import{u as n,j as e}from"./index-Bb_SBPIJ.js";import{Y as i}from"./_components-DLB4m9JY.js";const o="/assets/index-IJBOZvzh.png",h={description:"Advent of Code 2023 solutions and notes. Summary of my experience with the puzzles and the R language.",title:"Advent of Code 2023 notes"};function s(t){const a={a:"a",code:"code",em:"em",h1:"h1",img:"img",li:"li",p:"p",ul:"ul",...n(),...t.components};return e.jsxs(e.Fragment,{children:[e.jsx(a.h1,{children:"Advent of Code 2023 notes"}),`
`,`
`,`
`,e.jsx(i,{year:2023}),`
`,e.jsxs(a.p,{children:["2023 was supposedly my third year doing AoC, but I actually did it retrospectively in 2025. I was just appointed leader of ",e.jsx(a.a,{href:"https://coursetable.com/",children:"CourseTable"})," and I was grinding on it every day. When I chose a language for 2023 in retrospect, I actually had several candidates. First, I started learning Rust in early 2022, but I already happened to do ",e.jsx(a.a,{href:"/notes/aoc/2025/",children:"2025"})," with it; second, I learned Racket in late 2022 because my friends were all taking an ",e.jsx(a.a,{href:"https://coursetable.com/worksheet?course-modal=202203-10948",children:"intro CS"})," class, but I don't consider myself proficient enough (I might still revisit it in a future year); third, I learned R in early 2023 in a ",e.jsx(a.a,{href:"https://coursetable.com/worksheet?course-modal=202301-20528",children:"data analysis an exploration"})," class. Since then, in late 2023, I took another ",e.jsx(a.a,{href:"https://coursetable.com/worksheet?course-modal=202303-18256",children:"probability class"})," where I was intimidated by assignments using R, so overall it seemed like a year of R. If not now, when?"]}),`
`,e.jsxs(a.p,{children:["R was ",e.jsx(a.em,{children:"the most awkward"})," language I've ever touched. You can call it powerful and expressive et cetera, but for writing plain old algorithms, it's just a hot mess. Here are the things I've complained about this year:"]}),`
`,e.jsxs(a.ul,{children:[`
`,e.jsxs(a.li,{children:["No built-in hash maps or sets. String keys into lists are secretly linear under the hood. Even when you use hacks like ",e.jsx(a.code,{children:"new.env()"})," you still have to serialize complex keys into strings."]}),`
`,e.jsxs(a.li,{children:["Terrible typing, which is to say none. Meanwhile all the variable types are crazy complex with vectorization, ",e.jsx(a.code,{children:"sapply"}),"/",e.jsx(a.code,{children:"lapply"}),` and stuff. I have to constantly paste into ChatGPT "what's the type of this variable and how do I index into it".`]}),`
`,e.jsxs(a.li,{children:["No Int64, like at all?? I had to load ",e.jsx(a.a,{href:"https://cran.r-project.org/web/packages/gmp/index.html",children:"gmp"})," to use int64 (of which there were a lot that year!)."]}),`
`,e.jsx(a.li,{children:"1-indexing. This is not a problem in itself but it makes translating algorithms a bit harder, especially ones where the list indices are intended as keys rather than arbitrary positions."}),`
`,e.jsxs(a.li,{children:["Secret CoW. Hidden performance costs and subtle bugs everywhere. I always have to deep-modify like ",e.jsx(a.code,{children:"a[[i]][[j]][k] <- foo"})," without saving any intermediate variables."]}),`
`,e.jsx(a.li,{children:"And of course, performance was slow in general."}),`
`,e.jsxs(a.li,{children:['Compared to all of the above, problems like "no priority queues" and "no queues" seem such trivial problems especially since they are solved by the ',e.jsx(a.a,{href:"https://cran.r-project.org/web/packages/collections/index.html",children:"collections"})," package."]}),`
`]}),`
`,e.jsxs(a.p,{children:["On the upside, ",e.jsx(a.a,{href:"https://cran.r-project.org/web/packages/igraph/index.html",children:"igraph"})," was very helpful for graph problems like ",e.jsx(a.a,{href:"/notes/aoc/2023/20/",children:"20"}),", ",e.jsx(a.a,{href:"/notes/aoc/2023/23/",children:"23"}),", and ",e.jsx(a.a,{href:"/notes/aoc/2023/25/",children:"25"}),", and I did benefit from vectorization and data frame operations in many problems."]}),`
`,e.jsxs(a.p,{children:[`I enjoyed the "theme" this year, since I can clearly see the path we moved through: the different islands, up and down. I don't know if it's a "when you have a hammer" situation, but I find more math problems this year than average, as pure as `,e.jsx(a.a,{href:"/notes/aoc/2023/9/",children:"9"}),". There were even ",e.jsx(a.a,{href:"/notes/aoc/2023/10/",children:"two"})," ",e.jsx(a.a,{href:"/notes/aoc/2023/18/",children:"problems"})," involving the shoelace formula! Also more graphs and mazes than DP—which I appreciate because again it's not easy to memoize in R."]}),`
`,e.jsxs(a.p,{children:["Difficulty-wise, I think the difficulty is yet higher than 2022. Language problems aside, ",e.jsx(a.a,{href:"/notes/aoc/2023/5/",children:"5"})," actually gave me a hard time because I had to wrap my head around how the mappings compose. ",e.jsx(a.a,{href:"/notes/aoc/2023/8/",children:"8"})," was tricky as well, especially because it isn't obvious that the naïve solution should work and it's so apparently wrong in most cases. Then it went pretty smoothly until ",e.jsx(a.a,{href:"/notes/aoc/2023/20/",children:"20"})," where I spent a lot of time doing it generically before seeing that the circuit has structure. ",e.jsx(a.a,{href:"/notes/aoc/2023/21/",children:"21"})," is I'd consider the hardest problem of the year, and again the input is specially constructed so it's unnecessary to write a fully generic solution. ",e.jsx(a.a,{href:"/notes/aoc/2023/23/",children:"23"})," is also theoretically sophisticated. It's possible to get away with naïve DFS, but I spent a good amount of time optimizing it, particularly because R is so slow already. These monsters make ",e.jsx(a.a,{href:"/notes/aoc/2023/24/",children:"24"})," and ",e.jsx(a.a,{href:"/notes/aoc/2023/25/",children:"25"})," look like babies (especially when I can cheat with ",e.jsx(a.code,{children:"igraph"})," for 25)!"]}),`
`,e.jsx(a.p,{children:e.jsx(a.img,{src:o,alt:"landing page",width:1888,height:1490})})]})}function c(t={}){const{wrapper:a}={...n(),...t.components};return a?e.jsx(a,{...t,children:e.jsx(s,{...t})}):s(t)}export{c as default,h as frontMatter};
