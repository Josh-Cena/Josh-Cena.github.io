import{u as i,j as s}from"./index-BnEAZLVO.js";import{P as l,a as r}from"./_components-CRYqM7VG.js";import"./_commonjsHelpers-Cpj98o6Y.js";const n={tags:["Brute force","Data structures"],title:"Advent of Code 2020 - Day 1: Report Repair",description:"Advent of Code 2020 - Day 1: Report Repair, a problem that involves Brute force and Data structures. Solution written in Python, with detailed walkthrough and proof.",year:2020,day:1};function t(a){const e={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",semantics:"semantics",span:"span",...i(),...a.components};return s.jsxs(s.Fragment,{children:[s.jsxs(e.h1,{children:["Advent of Code 2020 - Day 1",s.jsx(e.span,{className:"subtitle",children:"Report Repair"})]}),`
`,`
`,s.jsx(l,{frontMatter:n}),`
`,s.jsx(e.h2,{children:"Part 1"}),`
`,s.jsxs(e.p,{children:["This is the classic ",s.jsx(e.a,{href:"https://leetcode.com/problems/two-sum/",children:"two-sum"})," problem, which should be familiar to anyone spending more than 5 minutes on LeetCode. A naïve solution is ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsxs(e.msup,{children:[s.jsx(e.mi,{children:"n"}),s.jsx(e.mn,{children:"2"})]}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(n^2)"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord mathnormal",children:"n"}),s.jsx(e.span,{className:"msupsub",children:s.jsx(e.span,{className:"vlist-t",children:s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.8141em"},children:s.jsxs(e.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"2"})})]})})})})})]}),s.jsx(e.span,{className:"mclose",children:")"})]})})]})," by checking all pairs; since the input is only 200 numbers and it is day 1, this is acceptable. A better solution is to use a hash set to store the numbers we have seen so far, and for each number, check if ",s.jsx(e.code,{children:"2020 - number"})," is in the set. This gives us an ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{children:"n"}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(n)"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsx(e.span,{className:"mord mathnormal",children:"n"}),s.jsx(e.span,{className:"mclose",children:")"})]})})]})," solution."]}),`
`,s.jsx(e.h2,{children:"Part 2"}),`
`,s.jsxs(e.p,{children:["This is yet another classic problem, ",s.jsx(e.a,{href:"https://leetcode.com/problems/3sum/",children:"three-sum"}),". The naïve solution is ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsxs(e.msup,{children:[s.jsx(e.mi,{children:"n"}),s.jsx(e.mn,{children:"3"})]}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(n^3)"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord mathnormal",children:"n"}),s.jsx(e.span,{className:"msupsub",children:s.jsx(e.span,{className:"vlist-t",children:s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.8141em"},children:s.jsxs(e.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"3"})})]})})})})})]}),s.jsx(e.span,{className:"mclose",children:")"})]})})]})," by checking all triplets; at 8,000,000 operations it's a bit out of hands, bt still doable. A better solution is to enumerate all pairs and use a hash set to check if ",s.jsx(e.code,{children:"2020 - (num1 + num2)"})," exists. This gives us an ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsxs(e.msup,{children:[s.jsx(e.mi,{children:"n"}),s.jsx(e.mn,{children:"2"})]}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(n^2)"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord mathnormal",children:"n"}),s.jsx(e.span,{className:"msupsub",children:s.jsx(e.span,{className:"vlist-t",children:s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.8141em"},children:s.jsxs(e.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"2"})})]})})})})})]}),s.jsx(e.span,{className:"mclose",children:")"})]})})]})," solution."]}),`
`,s.jsx(r,{frontMatter:n})]})}function d(a={}){const{wrapper:e}={...i(),...a.components};return e?s.jsx(e,{...a,children:s.jsx(t,{...a})}):t(a)}export{d as default,n as frontMatter};
