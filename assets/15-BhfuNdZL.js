import{u as r,j as n}from"./index-Bd1Aa8Z1.js";import{F as i,a as o}from"./_components-D86NrBj9.js";const s={tags:["Brute force","Data structures"],description:"Advent of Code 2020 - Day 15: Rambunctious Recitation, a problem that involves Brute force and Data structures. Solution written in Python, with detailed walkthrough and proof.",year:2020,day:15,title:"Advent of Code 2020 - Day 15: Rambunctious Recitation"};function a(e){const t={annotation:"annotation",code:"code",h1:"h1",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...r(),...e.components};return n.jsxs(n.Fragment,{children:[n.jsxs(t.h1,{children:["Advent of Code 2020 - Day 15",n.jsx(t.span,{className:"subtitle",children:"Rambunctious Recitation"})]}),`
`,`
`,n.jsx(i,{frontMatter:s}),`
`,n.jsxs(t.p,{children:["This is literally just simulating the game rules, no questions asked. While 30,000,000 turns is a lot, if we have an ",n.jsxs(t.span,{className:"katex",children:[n.jsx(t.span,{className:"katex-mathml",children:n.jsx(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:n.jsxs(t.semantics,{children:[n.jsxs(t.mrow,{children:[n.jsx(t.mi,{mathvariant:"script",children:"O"}),n.jsx(t.mo,{stretchy:"false",children:"("}),n.jsx(t.mi,{children:"n"}),n.jsx(t.mo,{stretchy:"false",children:")"})]}),n.jsx(t.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(n)"})]})})}),n.jsx(t.span,{className:"katex-html","aria-hidden":"true",children:n.jsxs(t.span,{className:"base",children:[n.jsx(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),n.jsx(t.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),n.jsx(t.span,{className:"mopen",children:"("}),n.jsx(t.span,{className:"mord mathnormal",children:"n"}),n.jsx(t.span,{className:"mclose",children:")"})]})})]})," algorithm, it's still feasible. The only bottleneck is finding the last occurrence of a number. Instead of storing all numbers physically in an array, notice that previous occurrences of the same number are irrelevant, so we should instead maintain a dictionary that maps each number to its last occurrence index."]}),`
`,n.jsx(t.pre,{children:n.jsx(t.code,{className:"language-python",children:`most_recent_turn = {x: i + 1 for i, x in enumerate(nums)}
last_num = nums[-1]
for i in range(len(nums) + 1, round + 1):
    num = i - 1 - most_recent_turn.get(last_num, i - 1)
    most_recent_turn[last_num] = i - 1
    last_num = num
print(last_num)
`})}),`
`,n.jsx(o,{frontMatter:s})]})}function m(e={}){const{wrapper:t}={...r(),...e.components};return t?n.jsx(t,{...e,children:n.jsx(a,{...e})}):a(e)}export{m as default,s as frontMatter};
