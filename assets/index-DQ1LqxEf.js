import{u as s,j as e}from"./index-DH0P7Lag.js";import{Y as n}from"./_components-BmaiIPu9.js";import"./_commonjsHelpers-Cpj98o6Y.js";const i="/assets/index-1JaNeHTZ.png",c={description:"Advent of Code 2024 solutions and notes. Summary of my experience with the puzzles and the OCaml language.",title:"Advent of Code 2024 notes"};function o(a){const t={a:"a",code:"code",em:"em",h1:"h1",img:"img",p:"p",...s(),...a.components};return e.jsxs(e.Fragment,{children:[e.jsx(t.h1,{children:"Advent of Code 2024 notes"}),`
`,`
`,e.jsx(n,{year:2024}),`
`,e.jsxs(t.p,{children:["2024 was supposedly my fourth year doing AoC, but I actually did it retrospectively in 2025. I was completely occupied with final season and schoolwork in December. The spring of 2024, I took the infamous ",e.jsx(t.a,{href:"https://coursetable.com/catalog?course-modal=202401-28082",children:"systems programming"})," class where I practiced Rust. Then in fall, I took a ",e.jsx(t.a,{href:"https://coursetable.com/catalog?course-modal=202403-10132",children:"compilers"})," class entirely in OCaml and a ",e.jsx(t.a,{href:"https://coursetable.com/catalog?course-modal=202403-10141",children:"software analysis and verification"})," class that was half-Haskell half-Rust. Later in spring 2025, I took a ",e.jsx(t.a,{href:"https://coursetable.com/catalog?course-modal=202501-22580",children:"formal semantics"})," class in Rocq. My prowess with programming languages grew significantly, and I decided to try out the new hammer in my toolbox: OCaml."]}),`
`,e.jsxs(t.p,{children:["I thought OCaml would be as elegant and enjoyable as Haskell, but it turned out to be on the other side of the spectrum. I pretty much lamented everything that Haskell has but OCaml lacks, and equally detested everything that OCaml exclusively has. For example, I can't resist using ",e.jsx(t.code,{children:"while"}),", arrays, and loops because they make my brain feel at ease, which I had to later refactor into recursion. On the other hand, I really missed Haskell's powerful abstractionsâ€”what's an FP language without function composition, lazy evaluation, and immutable collections? OCaml's standard library is also extremely bare-bones, especially compared to Haskell's. It doesn't even have a polymorphic print function."]}),`
`,e.jsxs(t.p,{children:["I enjoyed this year's tributes to past years' themes, although I only have experience with half of them. I did expect more connection in the actual ",e.jsx(t.em,{children:"puzzle"})," though, like same input format or similar algorithms, but looks like the connection is only present in the first paragraph or two."]}),`
`,e.jsxs(t.p,{children:["Difficulty-wise, I think 2024 is tuned down from 2022 and 2023. Everything was pretty frictionless until ",e.jsx(t.a,{href:"/notes/aoc/2024/14/",children:"14"}),", whose part 2 I had to search on Reddit for hints. ",e.jsx(t.a,{href:"/notes/aoc/2024/17/",children:"17"})," took a good amount of my time, but I enjoyed these VM problems as always. I would consider ",e.jsx(t.a,{href:"/notes/aoc/2024/18/",children:"18"})," demanding some thought (I messed up part 2 initially with node allocation, which I had to debug for a while). ",e.jsx(t.a,{href:"/notes/aoc/2024/21/",children:"21"})," is ",e.jsx(t.em,{children:"by far"})," the hardest problem of the year, and perhaps even the hardest of all times. I was traveling when doing this, and I spent a night and a train ride solving it. ",e.jsx(t.a,{href:"/notes/aoc/2024/23/",children:"23"})," is only hard because I can't cheat with ",e.jsx(t.code,{children:"igraph"})," or ",e.jsx(t.code,{children:"networkx"})," (which I would have done if I chose R or Python). ",e.jsx(t.a,{href:"/notes/aoc/2024/24/",children:"24"})," wasn't particularly ",e.jsx(t.em,{children:"hard"}),' (if one knows the structure of an adder) but very tedious to code up. My initial solution was more of a "computer-',e.jsx(t.em,{children:"assisted"}),' solution" since it stops every time a swap is continued, and only restarts when the swap is hard-coded in the source code. My revised algorithm gets rid of this, but it still relies on mercy of the input.']}),`
`,e.jsx(t.p,{children:e.jsx(t.img,{src:i,alt:"landing page",width:1888,height:1490})})]})}function d(a={}){const{wrapper:t}={...s(),...a.components};return t?e.jsx(t,{...a,children:e.jsx(o,{...a})}):o(a)}export{d as default,c as frontMatter};
