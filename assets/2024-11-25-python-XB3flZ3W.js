import{u as o,j as e}from"./index-DKP0lJ-S.js";import"./_commonjsHelpers-Cpj98o6Y.js";const r={description:"With the world obsessed with speed and specialization, Python proves that language design sells.",date:"2024-11-25",title:"In search for a good programming language: Python"};function a(n){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",section:"section",sup:"sup",ul:"ul",...o(),...n.components};return e.jsxs(e.Fragment,{children:[e.jsx(t.h1,{children:"In search for a good programming language: Python"}),`
`,e.jsx(t.p,{children:"Python is a language of which I've seen very few people say bad things, and I think that speaks something about the language design, given its demographics of users and the volume of hate that other languages get. The few criticisms I've heard about are centered around: (1) performance, (2) dynamic typing, (3) significant whitespace, and (4) the GIL. I don't think any of these are deal-breakers."}),`
`,e.jsxs(t.p,{children:[`Performance is of course the most-cited problem of Python, and it's basically the canonical example of "slow". Indeed, if you look at any benchmark (such as `,e.jsx(t.a,{href:"https://niklas-heer.github.io/speed-comparison/",children:"speed comparison"}),"), you would basically always find Python (CPython) at the bottom, perhaps next to Octave and Perl. PyPy grants performance on par with a bunch of mainstream languages, and if you want to go the extra mile, you would have to go native and use Julia, C, or Rust. But I think the problem is severely overstated. It is true that if you ever execute 10M lines of Python code, you probably have to wait a while, but in practice, the time spent in the Python realm is small compared to the underlying native library. Novices may be implementing entire list processing algorithms in Python, but any seasoned developer would know from muscle memory to offload the heavy lifting to native libraries like NumPy or Pandas. Nevertheless, the popularity of ",e.jsx(t.a,{href:"https://tqdm.github.io/",children:e.jsx(t.code,{children:"tqdm"})})," relative to other languages already says something about Python performance."]}),`
`,e.jsxs(t.p,{children:["Dynamic typing had caused me problems about 5 years ago, but time has moved on and the type checking ecosystem is getting better every year (I haven't used an untyped library in a while). Pyright is comparable to TypeScript in terms of ergonomics, although the type system, being standardized by PEP instead of a single team like TypeScript, is not half as powerful. Still, it's good enough for most use cases, and I have enjoyed its syntax and semantics more than TypeScript. Python, since its day 1, is also in a much better position than JavaScript at enforcing strictness, because it tends to reject invalid types instead of coercing them, and it has a much more consistent and predictable runtime type system. The ",e.jsx(t.code,{children:"int"}),"/",e.jsx(t.code,{children:"float"})," dichotomy is especially useful in most contexts."]}),`
`,e.jsx(t.p,{children:`I wouldn't consider significant whitespace a problem, and I'm baffled by who's getting tripped by it. Even in languages like C or Java, people are still expected to have consistent indentation, and it's not like people would seriously write code with random indentation. Haskell, also being a language with significant whitespace, has received close to no complaints in this regard, which speaks volumes about the demographics of the complainers. The meme of "writing Python with rulers" also seems to be dying out over the last 10 years, a sign of people migrating to real editors with real indentation support. Indeed, it shouldn't bother anyone writing code in an environment more sophisticated than Notepad.`}),`
`,e.jsxs(t.p,{children:["The GIL is a problem for sure, but I suspect some people citing it may not have a visceral understanding of it. To be honest, I fail to see how it's operationally different from JavaScript's single-threaded event loop. Both of them allow the creation of separate processes that communicate via some IPC mechanism, and you can use ",e.jsx(t.code,{children:"async"}),"/",e.jsx(t.code,{children:"await"})," to implement concurrency without parallelism within one process. ",e.jsx(t.a,{href:"https://peps.python.org/pep-0703/",children:"The GIL is also on its way out"}),", by the way."]}),`
`,e.jsxs(t.p,{children:["There are also some other tensions. Dependency management isn't easy in Python, especially with multiple Python versions and global package installations. (The recent ",e.jsx(t.a,{href:"https://docs.astral.sh/uv/",children:e.jsx(t.code,{children:"uv"})})," tool may solve it in the near future.) Python 2 to 3 transition was a nightmare for many. On the other hand, there are far more things that Python ",e.jsx(t.em,{children:"gets right"}),", which is very remarkable for a language that's as old as VB and Pascal. Module system; explicit ",e.jsx(t.code,{children:"self"})," parameter; strong typing (not to be confused with static typing); context managers; syntax for list/dict/set; operator overloading; the list can go on. It has consistent and high-quality aesthetics (which gives birth to things like ",e.jsx(t.code,{children:"True"})," and ",e.jsx(t.code,{children:"False"})," that may baffle some, but I find them laudable). All these features pave the way for a very pleasant programming experience."]}),`
`,e.jsx(t.p,{children:`Many people have pondered the question of "why Python". After all, it's not born in big corps (like VB for Microsoft, Go for Google, or Java for Sun), doesn't have monopoly on one platform (like browsers for JavaScript or iOS for Swift), doesn't have a unique selling point (like Rust for safety), and doesn't even have good performance. Its success proves that none of these are necessary for the acceptance of a language, which is certainly a morale boost for most PL designers: it's possible to attract users just by making your language beautiful and ergonomic without finding a niche.`}),`
`,e.jsxs(t.p,{children:["On the other hand, what would be the counterfactual had Python ",e.jsx(t.em,{children:"not"})," been the default scripting language? Tools like Django, NumPy, and Pandas only came out circa 2005, at which time we had many other thriving scripting languages like Ruby, PHP, Bash, Perl, JavaScript",e.jsx(t.sup,{children:e.jsx(t.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),e.jsx(t.sup,{children:e.jsx(t.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),". But when looking closer, it's immediately apparent that none of these could compete feature-wise (or even performance-wise) with Python:"]}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsx(t.li,{children:"Both Ruby and Perl are feature-complete and have a package ecosystem, but their syntaxes are less consistent and simplistic. Perl in particular has a very bad reputation for being unreadable, and Ruby is also more optimized for metaprogramming and DSLs."}),`
`,e.jsx(t.li,{children:"PHP and Bash are too much like DSLs and aren't ready for general-purpose programming. They lack data structures, have very inconsistent syntax, and are awkward to write once taken out of the context of web development or shell scripting."}),`
`,e.jsx(t.li,{children:"JavaScript had no package ecosystem at the time and Node.js didn't even exist until 2009. It was also pre-ES5 and full of incantations and quirks to do anything non-trivial."}),`
`]}),`
`,e.jsx(t.p,{children:"Under a comparison like this, Python is the only one that strikes the balance between expressiveness, dynamic typing, abstraction, and aesthetics. So perhaps the success of Python is not so much by chance—its forward-looking design deserves the attention it gets."}),`
`,e.jsxs(t.section,{"data-footnotes":!0,className:"footnotes",children:[e.jsx(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),`
`,e.jsxs(t.ol,{children:[`
`,e.jsxs(t.li,{id:"user-content-fn-1",children:[`
`,e.jsxs(t.p,{children:["It's also funny to remark that, except JavaScript, all of these languages appear at the bottom of the ",e.jsx(t.a,{href:"https://niklas-heer.github.io/speed-comparison/",children:"speed comparison"}),". ",e.jsx(t.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"↩"})]}),`
`]}),`
`,e.jsxs(t.li,{id:"user-content-fn-2",children:[`
`,e.jsxs(t.p,{children:[`Many people may say "Python succeeded because of NumPy/some other package", but it's a chicken-and-egg problem. Why must it be NumPy, and not NumJS or NumPHP? Once we start asking these questions, we start to go back to the language design itself. `,e.jsx(t.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"↩"})]}),`
`]}),`
`]}),`
`]})]})}function h(n={}){const{wrapper:t}={...o(),...n.components};return t?e.jsx(t,{...n,children:e.jsx(a,{...n})}):a(n)}export{h as default,r as frontMatter};
