import{u as i,j as s}from"./index-RGQIYrCD.js";import{P as l,a as r}from"./_components-QBhgxPvn.js";const n={tags:["Data structures"],description:"Advent of Code 2024 - Day 1: Historian Hysteria, a problem that involves Data structures. Solution written in OCaml, with detailed walkthrough and proof.",year:2024,day:1,title:"Advent of Code 2024 - Day 1: Historian Hysteria"};function t(e){const a={annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",math:"math",mi:"mi",mrow:"mrow",msub:"msub",p:"p",pre:"pre",semantics:"semantics",span:"span",...i(),...e.components};return s.jsxs(s.Fragment,{children:[s.jsxs(a.h1,{children:["Advent of Code 2024 - Day 1",s.jsx(a.span,{className:"subtitle",children:"Historian Hysteria"})]}),`
`,`
`,s.jsx(l,{frontMatter:n}),`
`,s.jsx(a.h2,{children:"Part 1"}),`
`,s.jsxs(a.p,{children:["After years of Haskell practice, I'm still getting used to what OCaml has and doesn't have, so this is a good warmup. Split each line, parse two numbers, then ",s.jsx(a.code,{children:"List.split"})," (OCaml's ",s.jsx(a.code,{children:"unzip"}),") to get two lists. Sort each of them, then zip them and sum the diffs."]}),`
`,s.jsx(a.pre,{children:s.jsx(a.code,{className:"language-ocaml",children:`let (nums1, nums2) = List.split (List.map (fun x ->
  match Str.split (Str.regexp " +") x with
  | [a; b] -> (int_of_string a, int_of_string b)
  | _ -> failwith "Invalid input") data) in
let nums1' = List.sort compare nums1 in
let nums2' = List.sort compare nums2 in
let differences = List.map2 (fun a b -> abs (b - a)) nums1' nums2' in
Printf.printf "%d\\n" (List.fold_left (+) 0 differences)
`})}),`
`,s.jsx(a.h2,{children:"Part 2"}),`
`,s.jsx(a.p,{children:"We want"}),`
`,s.jsx(a.span,{className:"katex-error",title:"ParseError: KaTeX parse error: Expected 'EOF', got '#' at position 24: …1}^n a_i \\cdot #̲(b, a_i)",style:{color:"#cc0000"},children:"\\sum_{i=1}^n a_i \\cdot #(b, a_i)"}),`
`,s.jsxs(a.p,{children:["where ",s.jsx(a.span,{className:"katex-error",title:"ParseError: KaTeX parse error: Expected 'EOF', got '#' at position 1: #̲(b, a_i)",style:{color:"#cc0000"},children:"#(b, a_i)"})," is the number of ",s.jsxs(a.span,{className:"katex",children:[s.jsx(a.span,{className:"katex-mathml",children:s.jsx(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(a.semantics,{children:[s.jsx(a.mrow,{children:s.jsxs(a.msub,{children:[s.jsx(a.mi,{children:"a"}),s.jsx(a.mi,{children:"i"})]})}),s.jsx(a.annotation,{encoding:"application/x-tex",children:"a_i"})]})})}),s.jsx(a.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(a.span,{className:"base",children:[s.jsx(a.span,{className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),s.jsxs(a.span,{className:"mord",children:[s.jsx(a.span,{className:"mord mathnormal",children:"a"}),s.jsx(a.span,{className:"msupsub",children:s.jsxs(a.span,{className:"vlist-t vlist-t2",children:[s.jsxs(a.span,{className:"vlist-r",children:[s.jsx(a.span,{className:"vlist",style:{height:"0.3117em"},children:s.jsxs(a.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[s.jsx(a.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(a.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(a.span,{className:"mord mathnormal mtight",children:"i"})})]})}),s.jsx(a.span,{className:"vlist-s",children:"​"})]}),s.jsx(a.span,{className:"vlist-r",children:s.jsx(a.span,{className:"vlist",style:{height:"0.15em"},children:s.jsx(a.span,{})})})]})})]})]})})]}),"'s in the list ",s.jsxs(a.span,{className:"katex",children:[s.jsx(a.span,{className:"katex-mathml",children:s.jsx(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(a.semantics,{children:[s.jsx(a.mrow,{children:s.jsx(a.mi,{children:"b"})}),s.jsx(a.annotation,{encoding:"application/x-tex",children:"b"})]})})}),s.jsx(a.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(a.span,{className:"base",children:[s.jsx(a.span,{className:"strut",style:{height:"0.6944em"}}),s.jsx(a.span,{className:"mord mathnormal",children:"b"})]})})]}),". This is equivalent to"]}),`
`,s.jsx(a.span,{className:"katex-error",title:"ParseError: KaTeX parse error: Expected 'EOF', got '#' at position 27: …n a} a_i \\cdot #̲(a, a_i) \\cdot …",style:{color:"#cc0000"},children:"\\sum_{a_i\\in a} a_i \\cdot #(a, a_i) \\cdot #(b, a_i)"}),`
`,s.jsxs(a.p,{children:["where ",s.jsxs(a.span,{className:"katex",children:[s.jsx(a.span,{className:"katex-mathml",children:s.jsx(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(a.semantics,{children:[s.jsx(a.mrow,{children:s.jsx(a.mi,{children:"a"})}),s.jsx(a.annotation,{encoding:"application/x-tex",children:"a"})]})})}),s.jsx(a.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(a.span,{className:"base",children:[s.jsx(a.span,{className:"strut",style:{height:"0.4306em"}}),s.jsx(a.span,{className:"mord mathnormal",children:"a"})]})})]})," is the set of ",s.jsx(a.em,{children:"unique"})," elements in the list ",s.jsxs(a.span,{className:"katex",children:[s.jsx(a.span,{className:"katex-mathml",children:s.jsx(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(a.semantics,{children:[s.jsx(a.mrow,{children:s.jsx(a.mi,{children:"a"})}),s.jsx(a.annotation,{encoding:"application/x-tex",children:"a"})]})})}),s.jsx(a.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(a.span,{className:"base",children:[s.jsx(a.span,{className:"strut",style:{height:"0.4306em"}}),s.jsx(a.span,{className:"mord mathnormal",children:"a"})]})})]}),". We can compute this by first counting the occurrences of each unique element in ",s.jsxs(a.span,{className:"katex",children:[s.jsx(a.span,{className:"katex-mathml",children:s.jsx(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(a.semantics,{children:[s.jsx(a.mrow,{children:s.jsx(a.mi,{children:"a"})}),s.jsx(a.annotation,{encoding:"application/x-tex",children:"a"})]})})}),s.jsx(a.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(a.span,{className:"base",children:[s.jsx(a.span,{className:"strut",style:{height:"0.4306em"}}),s.jsx(a.span,{className:"mord mathnormal",children:"a"})]})})]})," and ",s.jsxs(a.span,{className:"katex",children:[s.jsx(a.span,{className:"katex-mathml",children:s.jsx(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(a.semantics,{children:[s.jsx(a.mrow,{children:s.jsx(a.mi,{children:"b"})}),s.jsx(a.annotation,{encoding:"application/x-tex",children:"b"})]})})}),s.jsx(a.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(a.span,{className:"base",children:[s.jsx(a.span,{className:"strut",style:{height:"0.6944em"}}),s.jsx(a.span,{className:"mord mathnormal",children:"b"})]})})]}),", then summing over the unique elements in ",s.jsxs(a.span,{className:"katex",children:[s.jsx(a.span,{className:"katex-mathml",children:s.jsx(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(a.semantics,{children:[s.jsx(a.mrow,{children:s.jsx(a.mi,{children:"a"})}),s.jsx(a.annotation,{encoding:"application/x-tex",children:"a"})]})})}),s.jsx(a.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(a.span,{className:"base",children:[s.jsx(a.span,{className:"strut",style:{height:"0.4306em"}}),s.jsx(a.span,{className:"mord mathnormal",children:"a"})]})})]}),"."]}),`
`,s.jsxs(a.p,{children:["OCaml doesn't have a straightforward way to count occurrences (!) so I have to DIY via ",s.jsx(a.code,{children:"Map.Make (Int)"}),"."]}),`
`,s.jsx(a.pre,{children:s.jsx(a.code,{className:"language-ocaml",children:`module IntMap = Map.Make (Int)

let counts lst =
  List.fold_left
    (fun acc x ->
      IntMap.update x (function None -> Some 1 | Some n -> Some (n + 1)) acc)
    IntMap.empty lst

(* Within solve2 *)
let counts1 = counts nums1 in
let counts2 = counts nums2 in
let join_counts =
  IntMap.merge
    (fun _ c1 c2 ->
      match (c1, c2) with Some n1, Some n2 -> Some (n1 * n2) | _ -> None)
    counts1 counts2
in
Printf.printf "%d\\n" (IntMap.fold (fun k v acc -> acc + (k * v)) join_counts 0)
`})}),`
`,s.jsx(r,{frontMatter:n})]})}function h(e={}){const{wrapper:a}={...i(),...e.components};return a?s.jsx(a,{...e,children:s.jsx(t,{...e})}):t(e)}export{h as default,n as frontMatter};
