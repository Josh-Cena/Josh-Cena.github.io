import{u as i,j as s}from"./index-DKP0lJ-S.js";import{P as l,a as r}from"./_components-DSPmqsHQ.js";import"./_commonjsHelpers-Cpj98o6Y.js";const n={tags:["Modular arithmetic"],title:"Advent of Code 2022 - Day 11: Monkey in the Middle",description:"Advent of Code 2022 - Day 11: Monkey in the Middle, a problem that involves Modular arithmetic. Solution written in Haskell, with detailed walkthrough and proof.",year:2022,day:11};function t(a){const e={annotation:"annotation",code:"code",em:"em",h1:"h1",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",msubsup:"msubsup",p:"p",pre:"pre",semantics:"semantics",span:"span",...i(),...a.components};return s.jsxs(s.Fragment,{children:[s.jsxs(e.h1,{children:["Advent of Code 2022 - Day 11",s.jsx(e.span,{className:"subtitle",children:"Monkey in the Middle"})]}),`
`,`
`,s.jsx(l,{frontMatter:n}),`
`,s.jsxs(e.p,{children:["Part 1 is straightforward to simulate, and has the exact same idea as part 2 anyway, so I describe my part 2 solution here. Because the numbers get large, we need a way to keep them manageable. The key observation is that we don't care about the actual numbers: all tests are testing divisibility, so only the remainders matter. If for monkeys ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mn,{children:"1.."}),s.jsx(e.mi,{children:"n"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"1..n"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"0.6444em"}}),s.jsx(e.span,{className:"mord",children:"1.."}),s.jsx(e.span,{className:"mord mathnormal",children:"n"})]})})]}),", we have divisors ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsxs(e.msub,{children:[s.jsx(e.mi,{children:"d"}),s.jsx(e.mn,{children:"1"})]}),s.jsx(e.mo,{separator:"true",children:","}),s.jsxs(e.msub,{children:[s.jsx(e.mi,{children:"d"}),s.jsx(e.mn,{children:"2"})]}),s.jsx(e.mo,{separator:"true",children:","}),s.jsx(e.mo,{children:"…"}),s.jsx(e.mo,{separator:"true",children:","}),s.jsxs(e.msub,{children:[s.jsx(e.mi,{children:"d"}),s.jsx(e.mi,{children:"n"})]})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"d_1, d_2, \\ldots, d_n"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord mathnormal",children:"d"}),s.jsx(e.span,{className:"msupsub",children:s.jsxs(e.span,{className:"vlist-t vlist-t2",children:[s.jsxs(e.span,{className:"vlist-r",children:[s.jsx(e.span,{className:"vlist",style:{height:"0.3011em"},children:s.jsxs(e.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"1"})})]})}),s.jsx(e.span,{className:"vlist-s",children:"​"})]}),s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.15em"},children:s.jsx(e.span,{})})})]})})]}),s.jsx(e.span,{className:"mpunct",children:","}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord mathnormal",children:"d"}),s.jsx(e.span,{className:"msupsub",children:s.jsxs(e.span,{className:"vlist-t vlist-t2",children:[s.jsxs(e.span,{className:"vlist-r",children:[s.jsx(e.span,{className:"vlist",style:{height:"0.3011em"},children:s.jsxs(e.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"2"})})]})}),s.jsx(e.span,{className:"vlist-s",children:"​"})]}),s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.15em"},children:s.jsx(e.span,{})})})]})})]}),s.jsx(e.span,{className:"mpunct",children:","}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),s.jsx(e.span,{className:"minner",children:"…"}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),s.jsx(e.span,{className:"mpunct",children:","}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord mathnormal",children:"d"}),s.jsx(e.span,{className:"msupsub",children:s.jsxs(e.span,{className:"vlist-t vlist-t2",children:[s.jsxs(e.span,{className:"vlist-r",children:[s.jsx(e.span,{className:"vlist",style:{height:"0.1514em"},children:s.jsxs(e.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mathnormal mtight",children:"n"})})]})}),s.jsx(e.span,{className:"vlist-s",children:"​"})]}),s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.15em"},children:s.jsx(e.span,{})})})]})})]})]})})]}),", then keeping track of the remainder modulo ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{children:"D"}),s.jsx(e.mo,{children:"="}),s.jsxs(e.msubsup,{children:[s.jsx(e.mo,{children:"∏"}),s.jsxs(e.mrow,{children:[s.jsx(e.mi,{children:"i"}),s.jsx(e.mo,{children:"="}),s.jsx(e.mn,{children:"1"})]}),s.jsx(e.mi,{children:"n"})]}),s.jsxs(e.msub,{children:[s.jsx(e.mi,{children:"d"}),s.jsx(e.mi,{children:"i"})]})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"D = \\prod_{i=1}^n d_i"})]})})}),s.jsxs(e.span,{className:"katex-html","aria-hidden":"true",children:[s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"0.6833em"}}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"D"}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.2778em"}}),s.jsx(e.span,{className:"mrel",children:"="}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1.104em",verticalAlign:"-0.2997em"}}),s.jsxs(e.span,{className:"mop",children:[s.jsx(e.span,{className:"mop op-symbol small-op",style:{position:"relative",top:"0em"},children:"∏"}),s.jsx(e.span,{className:"msupsub",children:s.jsxs(e.span,{className:"vlist-t vlist-t2",children:[s.jsxs(e.span,{className:"vlist-r",children:[s.jsxs(e.span,{className:"vlist",style:{height:"0.8043em"},children:[s.jsxs(e.span,{style:{top:"-2.4003em",marginLeft:"0em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsxs(e.span,{className:"mord mtight",children:[s.jsx(e.span,{className:"mord mathnormal mtight",children:"i"}),s.jsx(e.span,{className:"mrel mtight",children:"="}),s.jsx(e.span,{className:"mord mtight",children:"1"})]})})]}),s.jsxs(e.span,{style:{top:"-3.2029em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mathnormal mtight",children:"n"})})]})]}),s.jsx(e.span,{className:"vlist-s",children:"​"})]}),s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.2997em"},children:s.jsx(e.span,{})})})]})})]}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord mathnormal",children:"d"}),s.jsx(e.span,{className:"msupsub",children:s.jsxs(e.span,{className:"vlist-t vlist-t2",children:[s.jsxs(e.span,{className:"vlist-r",children:[s.jsx(e.span,{className:"vlist",style:{height:"0.3117em"},children:s.jsxs(e.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mathnormal mtight",children:"i"})})]})}),s.jsx(e.span,{className:"vlist-s",children:"​"})]}),s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.15em"},children:s.jsx(e.span,{})})})]})})]})]})]})]})," is sufficient to determine the outcome of all tests. (To be fully robust we should probably use ",s.jsx(e.code,{children:"lcm"})," instead of multiplication, but it turned out that all ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsx(e.mrow,{children:s.jsxs(e.msub,{children:[s.jsx(e.mi,{children:"d"}),s.jsx(e.mi,{children:"i"})]})}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"d_i"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"0.8444em",verticalAlign:"-0.15em"}}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord mathnormal",children:"d"}),s.jsx(e.span,{className:"msupsub",children:s.jsxs(e.span,{className:"vlist-t vlist-t2",children:[s.jsxs(e.span,{className:"vlist-r",children:[s.jsx(e.span,{className:"vlist",style:{height:"0.3117em"},children:s.jsxs(e.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mathnormal mtight",children:"i"})})]})}),s.jsx(e.span,{className:"vlist-s",children:"​"})]}),s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.15em"},children:s.jsx(e.span,{})})})]})})]})]})})]})," are prime numbers.) Because modular arithmetic is closed under addition and multiplication, nothing else changes."]}),`
`,s.jsx(e.p,{children:"I parse the monkeys into the following record type:"}),`
`,s.jsx(e.pre,{children:s.jsx(e.code,{className:"language-hs",children:`data Monkey = Monkey
  { items :: [Int],
    operation :: Int -> Int,
    test :: Int,
    target1 :: Int,
    target2 :: Int,
    inspectTimes :: Int
  }
`})}),`
`,s.jsxs(e.p,{children:["(",s.jsx(e.code,{children:"old * old"})," is represented as ",s.jsx(e.code,{children:"(^ 2)"}),"; all other operations are either addition or multiplication by a constant.)"]}),`
`,s.jsxs(e.p,{children:["The main function just calls the ",s.jsx(e.code,{children:"passAround"})," function, which runs the given number of rounds. The ",s.jsx(e.code,{children:"reducer"})," is used to ",s.jsx(e.em,{children:"reduce"})," the worry level after each inspection, which is ```div",s.jsx(e.code,{children:"relief"}),"mod",s.jsx(e.code,{children:"divisor``. In part 1,"}),"relief",s.jsx(e.code,{children:"is 3, and in part 2,"}),"relief",s.jsx(e.code,{children:"is 1. Each time we fold over the monkeys and update the"}),"monkeys",s.jsx(e.code,{children:"map by passing items around, as in"}),"monkeyDoRound`."]}),`
`,s.jsx(e.pre,{children:s.jsx(e.code,{className:"language-hs",children:`passAround :: Int -> Int -> Map Int Monkey -> Map Int Monkey
passAround rounds relief monkeys = foldr ($) monkeys $ replicate rounds $ doRound (relief, divisor)
  where
    divisor = Map.foldr ((*) . test) 1 monkeys
    doRound reducer monkeys = foldl' (monkeyDoRound reducer) monkeys (Map.keys monkeys)
`})}),`
`,s.jsxs(e.p,{children:["In ",s.jsx(e.code,{children:"monkeyDoRound"}),", the items get emptied and appended to the target monkeys' item lists. The ",s.jsx(e.code,{children:"inspectTimes"})," is incremented by the number of items inspected."]}),`
`,s.jsx(e.pre,{children:s.jsx(e.code,{className:"language-hs",children:`monkeyDoRound :: (Int, Int) -> Map Int Monkey -> Int -> Map Int Monkey
monkeyDoRound reducer monkeys k = updateSelf $ foldr throwToTarget monkeys targets
  where
    monkey = monkeys Map.! k
    targets = map (monkeyInspect monkey reducer) $ items monkey
    updateSelf = Map.adjust (\\m -> m {items = [], inspectTimes = inspectTimes m + length targets}) k
    throwToTarget (target, item) = Map.adjust (\\m -> m {items = item : items m}) target
`})}),`
`,s.jsxs(e.p,{children:["The target determination is done by the ",s.jsx(e.code,{children:"monkeyInspect"})," function, which applies the operation, reduces the worry level, and checks the test condition."]}),`
`,s.jsx(e.pre,{children:s.jsx(e.code,{className:"language-hs",children:"monkeyInspect :: Monkey -> (Int, Int) -> Int -> (Int, Int)\nmonkeyInspect (Monkey {operation, test, target1, target2}) (relief, divisor) item = (target, item')\n  where\n    item' = operation item `div` relief `mod` divisor\n    target = if item' `mod` test == 0 then target1 else target2\n"})}),`
`,s.jsxs(e.p,{children:["Other than the modular arithmetic, everything else is straightforward simulation, which is ",s.jsx(e.em,{children:"slightly"})," awkward in Haskell, but not too bad."]}),`
`,s.jsx(r,{frontMatter:n})]})}function d(a={}){const{wrapper:e}={...i(),...a.components};return e?s.jsx(e,{...a,children:s.jsx(t,{...a})}):t(a)}export{d as default,n as frontMatter};
