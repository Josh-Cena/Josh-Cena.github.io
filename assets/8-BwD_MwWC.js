import{u as i,j as s}from"./index-BfdjqJwq.js";import{P as t,a as r}from"./_components-DIXLoOhb.js";import"./_commonjsHelpers-Cpj98o6Y.js";const n={tags:["Data structures"],title:"Advent of Code 2025 - Day 8: Playground",description:"Advent of Code 2025 - Day 8: Playground, a problem that involves Data structures. Solution written in Rust, with detailed walkthrough and proof.",year:2025,day:8};function l(a){const e={annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",...i(),...a.components};return s.jsxs(s.Fragment,{children:[s.jsxs(e.h1,{children:["Advent of Code 2025 - Day 8",s.jsx(e.span,{className:"subtitle",children:"Playground"})]}),`
`,`
`,s.jsx(t,{frontMatter:n}),`
`,s.jsx(e.h2,{children:"Part 1"}),`
`,s.jsx(e.p,{children:"First collect the distance between each pair of point (more precisely, squared distance to avoid floating point issues)."}),`
`,s.jsx(e.pre,{children:s.jsx(e.code,{className:"language-rust",children:`let mut dist: Vec<(i64, usize, usize)> = Vec::new();
for i in 0..coords.len() {
    for j in i + 1..coords.len() {
        let d = (coords[i][0] - coords[j][0]).pow(2)
            + (coords[i][1] - coords[j][1]).pow(2)
            + (coords[i][2] - coords[j][2]).pow(2);
        dist.push((d, i, j));
    }
}
`})}),`
`,s.jsxs(e.p,{children:["Now, the naïve way is to sort all edges by distance, which is ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"V"}),s.jsxs(e.msup,{children:[s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mn,{children:"2"})]}),s.jsx(e.mi,{children:"log"}),s.jsx(e.mo,{children:"⁡"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"V"}),s.jsxs(e.msup,{children:[s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mn,{children:"2"})]}),s.jsx(e.mo,{stretchy:"false",children:")"}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(|V|^2 \\log (|V|^2))"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"msupsub",children:s.jsx(e.span,{className:"vlist-t",children:s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.8141em"},children:s.jsxs(e.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"2"})})]})})})})})]}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),s.jsxs(e.span,{className:"mop",children:["lo",s.jsx(e.span,{style:{marginRight:"0.01389em"},children:"g"})]}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"msupsub",children:s.jsx(e.span,{className:"vlist-t",children:s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.8141em"},children:s.jsxs(e.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"2"})})]})})})})})]}),s.jsx(e.span,{className:"mclose",children:"))"})]})})]}),".; but note that we don't need that many edges, so most of the ordering is useless. Turns out that ",s.jsx(e.em,{children:"on-demand"})," sorting is possible with a heap. Heapifying a list is ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{children:"n"}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(n)"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsx(e.span,{className:"mord mathnormal",children:"n"}),s.jsx(e.span,{className:"mclose",children:")"})]})})]}),", and each pop is ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{children:"log"}),s.jsx(e.mo,{children:"⁡"}),s.jsx(e.mi,{children:"n"}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(\\log n)"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsxs(e.span,{className:"mop",children:["lo",s.jsx(e.span,{style:{marginRight:"0.01389em"},children:"g"})]}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),s.jsx(e.span,{className:"mord mathnormal",children:"n"}),s.jsx(e.span,{className:"mclose",children:")"})]})})]}),", so the total time is ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"V"}),s.jsxs(e.msup,{children:[s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mn,{children:"2"})]}),s.jsx(e.mo,{children:"+"}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"E"}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"log"}),s.jsx(e.mo,{children:"⁡"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"V"}),s.jsxs(e.msup,{children:[s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mn,{children:"2"})]}),s.jsx(e.mo,{stretchy:"false",children:")"}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(|V|^2 + |E| \\log (|V|^2))"})]})})}),s.jsxs(e.span,{className:"katex-html","aria-hidden":"true",children:[s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"msupsub",children:s.jsx(e.span,{className:"vlist-t",children:s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.8141em"},children:s.jsxs(e.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"2"})})]})})})})})]}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.2222em"}}),s.jsx(e.span,{className:"mbin",children:"+"}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),s.jsxs(e.span,{className:"mop",children:["lo",s.jsx(e.span,{style:{marginRight:"0.01389em"},children:"g"})]}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"msupsub",children:s.jsx(e.span,{className:"vlist-t",children:s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.8141em"},children:s.jsxs(e.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"2"})})]})})})})})]}),s.jsx(e.span,{className:"mclose",children:"))"})]})]})]}),", which is much better than the previous approach. To make Rust's ",s.jsx(e.code,{children:"BinaryHeap"})," work as a min-heap, we can wrap the values in ",s.jsx(e.code,{children:"Reverse"}),"."]}),`
`,s.jsx(e.pre,{children:s.jsx(e.code,{className:"language-rust",children:`let mut heap = BinaryHeap::from_iter(dist.into_iter().map(Reverse));
for _ in 0..num_conn {
    let (_, a, b) = heap.pop().unwrap().0;
    // ...
}
`})}),`
`,s.jsxs(e.p,{children:["Then we can connect each pair of points in order of distance. I could have used adjacency lists and BFS, which would have time ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"E"}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mo,{children:"+"}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"V"}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(|E| + |V|)"})]})})}),s.jsxs(e.span,{className:"katex-html","aria-hidden":"true",children:[s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.2222em"}}),s.jsx(e.span,{className:"mbin",children:"+"}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mclose",children:")"})]})]})]}),", but since we are only interested in the number of components, I use a union-find data structure instead, which turns out to be very useful for part 2 as well. Theoretically, this should be ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"E"}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mo,{children:"+"}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"V"}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mo,{stretchy:"false",children:")"}),s.jsx(e.mi,{children:"α"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"V"}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mo,{stretchy:"false",children:")"}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}((|E| + |V|) \\alpha(|V|))"})]})})}),s.jsxs(e.span,{className:"katex-html","aria-hidden":"true",children:[s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"(("}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.2222em"}}),s.jsx(e.span,{className:"mbin",children:"+"}),s.jsx(e.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mclose",children:")"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.0037em"},children:"α"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mclose",children:"))"})]})]})]}),", which is slightly worse than BFS, but in practice both are dwarfed by the ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"V"}),s.jsxs(e.msup,{children:[s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mn,{children:"2"})]}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(|V|^2)"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.22222em"},children:"V"}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"msupsub",children:s.jsx(e.span,{className:"vlist-t",children:s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.8141em"},children:s.jsxs(e.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"2"})})]})})})})})]}),s.jsx(e.span,{className:"mclose",children:")"})]})})]})," distance calculation."]}),`
`,s.jsx(e.pre,{children:s.jsx(e.code,{className:"language-rust",children:`let mut uf = QuickUnionUf::<UnionBySize>::new(coords.len());
for _ in 0..num_conn {
    let Reverse((_, a, b)) = heap.pop().unwrap();
    uf.union(a, b);
}
let mut sizes = HashMap::new();
for i in 0..coords.len() {
    let root = uf.find(i);
    *sizes.entry(root).or_insert(0) += 1;
}
`})}),`
`,s.jsx(e.p,{children:"Finally I just get the top 3 sizes and multiply them together."}),`
`,s.jsx(e.h2,{children:"Part 2"}),`
`,s.jsxs(e.p,{children:["I believe that the naïve solution is to run a BFS for every additional edge until we have only one component left. However, this is at least ",s.jsxs(e.span,{className:"katex",children:[s.jsx(e.span,{className:"katex-mathml",children:s.jsx(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:s.jsxs(e.semantics,{children:[s.jsxs(e.mrow,{children:[s.jsx(e.mi,{mathvariant:"script",children:"O"}),s.jsx(e.mo,{stretchy:"false",children:"("}),s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mi,{children:"E"}),s.jsxs(e.msup,{children:[s.jsx(e.mi,{mathvariant:"normal",children:"∣"}),s.jsx(e.mn,{children:"2"})]}),s.jsx(e.mo,{stretchy:"false",children:")"})]}),s.jsx(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(|E|^2)"})]})})}),s.jsx(e.span,{className:"katex-html","aria-hidden":"true",children:s.jsxs(e.span,{className:"base",children:[s.jsx(e.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),s.jsx(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),s.jsx(e.span,{className:"mopen",children:"("}),s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),s.jsxs(e.span,{className:"mord",children:[s.jsx(e.span,{className:"mord",children:"∣"}),s.jsx(e.span,{className:"msupsub",children:s.jsx(e.span,{className:"vlist-t",children:s.jsx(e.span,{className:"vlist-r",children:s.jsx(e.span,{className:"vlist",style:{height:"0.8141em"},children:s.jsxs(e.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[s.jsx(e.span,{className:"pstrut",style:{height:"2.7em"}}),s.jsx(e.span,{className:"sizing reset-size6 size3 mtight",children:s.jsx(e.span,{className:"mord mtight",children:"2"})})]})})})})})]}),s.jsx(e.span,{className:"mclose",children:")"})]})})]}),". Since I already have a union-find, this becomes much easier. I just keep track of the number of components, and stop when it reaches 1. I decrement the number of components every time I union two components together—when ",s.jsx(e.code,{children:"union()"})," returns ",s.jsx(e.code,{children:"true"}),"."]}),`
`,s.jsx(e.pre,{children:s.jsx(e.code,{className:"language-rust",children:`let mut uf = QuickUnionUf::<UnionBySize>::new(coords.len());
let mut num_components = coords.len();
loop {
   let Reverse((_, a, b)) = heap.pop().unwrap();
    if uf.union(a, b) {
        num_components -= 1;
    }
    if num_components == 1 {
        println!("{}", coords[a][0] * coords[b][0]);
        break;
    }
}
`})}),`
`,s.jsx(e.p,{children:"By the way, initially I had a wrong solution, which was basically this:"}),`
`,s.jsx(e.pre,{children:s.jsx(e.code,{className:"language-rust",children:`let mut disconnected = HashSet::from_iter(0..coords.len());
loop {
    let Reverse((_, a, b)) = heap.pop().unwrap();
    disconnected.remove(&a);
    disconnected.remove(&b);
    if disconnected.len() == 0 {
        println!("{}", coords[a][0] * coords[b][0]);
        break;
    }
}
`})}),`
`,s.jsx(e.p,{children:"However, this would break as soon as every component has size greater than 1, not when there is only one component left. I didn't even realize I was wrong before I started writing this writeup. I guess I just got lucky."}),`
`,s.jsx(r,{frontMatter:n})]})}function d(a={}){const{wrapper:e}={...i(),...a.components};return e?s.jsx(e,{...a,children:s.jsx(l,{...a})}):l(a)}export{d as default,n as frontMatter};
