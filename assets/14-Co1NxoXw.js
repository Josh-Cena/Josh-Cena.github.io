import{u as a,j as n}from"./index-TXYOrs-s.js";import{P as r,a as i}from"./_components-D-appPx2.js";import"./_commonjsHelpers-Cpj98o6Y.js";const t={tags:["Grid walking","Manual inspection"],title:"Advent of Code 2024 - Day 14: Restroom Redoubt",description:"Advent of Code 2024 - Day 14: Restroom Redoubt, a problem that involves Grid walking and Manual inspection. Solution written in OCaml, with detailed walkthrough and proof.",year:2024,day:14};function s(o){const e={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",span:"span",...a(),...o.components};return n.jsxs(n.Fragment,{children:[n.jsxs(e.h1,{children:["Advent of Code 2024 - Day 14",n.jsx(e.span,{className:"subtitle",children:"Restroom Redoubt"})]}),`
`,`
`,n.jsx(r,{frontMatter:t}),`
`,n.jsx(e.p,{children:"This problem pays tribute to 2016 day 2 (unimplemented)."}),`
`,n.jsx(e.h2,{children:"Part 1"}),`
`,n.jsxs(e.p,{children:[`Not much to say about it...? Just move each robot, wrapping around as needed. (Btw, I'm unhappy with how OCaml, a "functional" language, doesn't even have functions for applying a function `,n.jsx(e.code,{children:"n"})," times, or function composition.)"]}),`
`,n.jsx(e.pre,{children:n.jsx(e.code,{className:"language-ocaml",children:`let pos_mod x y =
  let r = x mod y in
  if r < 0 then r + y else r

let move_robot w h ((px, py), (vx, vy)) =
  ((pos_mod (px + vx) w, pos_mod (py + vy) h), (vx, vy))
`})}),`
`,n.jsx(e.pre,{children:n.jsx(e.code,{className:"language-ocaml",children:`let rec loop n pos =
  if n = 100 then pos else loop (n + 1) (List.map (move_robot w h) pos)
in
let new_pos = loop 0 robots in
let quadrants = List.map (fun ((px, py), _) -> quadrant w h px py) new_pos in
let counts = Array.make 4 0 in
List.iter (fun q -> if q >= 0 then counts.(q) <- counts.(q) + 1) quadrants;
Printf.printf "%d\\n" (Array.fold_left ( * ) 1 counts)
`})}),`
`,n.jsx(e.h2,{children:"Part 2"}),`
`,n.jsx(e.p,{children:"A very remarkable problem. I've seen all kinds of approaches on Reddit; the one I enjoyed the most was to save each board as JPEG and see which one compresses the best. I think the intended solution is to detect edges since an actual picture should have a lot of straight, smooth edges. However, I used a hack. I assumed that the input is reverse-constructed from an existing image of the Christmas tree, and this eventual position has no overlapping robots (thanks, Reddit wisdom). Any previous state should have some robots overlapping due to them randomly walking around."}),`
`,n.jsx(e.pre,{children:n.jsx(e.code,{className:"language-ocaml",children:`let rec loop n board =
  if n = 10000 then ()
  else
    let new_pos = List.map (move_robot w h) board in
    let pos_count = Hashtbl.create 100 in
    List.iter
      (fun ((px, py), _) ->
        let key = (px, py) in
        Hashtbl.replace pos_count key
          (1 + Option.fold ~none:0 ~some:(fun x -> x) (Hashtbl.find_opt pos_count key)))
      new_pos;
    if Hashtbl.fold (fun _ count acc -> acc && count = 1) pos_count true then (
      Printf.printf "t=%d\\n" (n + 1);
      print_board w h new_pos);
    loop (n + 1) new_pos
in
loop 0 robots
`})}),`
`,n.jsx(e.p,{children:"As always, let me appreciate this ASCII art (irrelevant padding cropped):"}),`
`,n.jsx(e.pre,{children:n.jsx(e.code,{className:"language-plain",children:`.....................................
...................#.................
.....................................
...###############################...
...#.............................#...
...#.............................#...
...#.............................#...
...#.............................#...
...#..............#..............#...
...#.............###.............#...
...#............#####............#...
...#...........#######...........#...
...#..........#########..........#...
...#............#####............#...
...#...........#######...........#...
...#..........#########..........#...
...#.........###########.........#...
...#........#############........#...
...#..........#########..........#...
...#.........###########.........#...
#..#........#############........#...
...#.......###############.......#...
#..#......#################......#...
...#........#############........#...
...#.......###############.......#...
...#......#################......#...
...#.....###################.....#...
...#....#####################....#...
...#.............###.............#...
...#.............###.............#...
...#.............###.............#...
...#.............................#...
...#.............................#...
...#.............................#...
...#.............................#...
...###############################...
....................................#
...................#.................
.........................#...........
`})}),`
`,n.jsx(i,{frontMatter:t})]})}function c(o={}){const{wrapper:e}={...a(),...o.components};return e?n.jsx(e,{...o,children:n.jsx(s,{...o})}):s(o)}export{c as default,t as frontMatter};
