---
description: "Advent of Code 2021 - Day 8: Seven Segment Search. Written in TypeScript."
tags:
  - Constraint satisfaction
year: 2021
day: 8
---

# AoC 2021 D8: Seven Segment Search

import { FrontMatter, Footer } from "../_components";

<FrontMatter frontMatter={frontMatter} />

## Part 1

Fun problem, but not much to say here. `1` uses 2 segments, `4` uses 4 segments, `7` uses 3 segments, and `8` uses all 7 segments. Just count how many times these lengths appear in the output values.

```ts
const count = data
  .map((line) => line.split(" | ")[1])
  .flatMap((output) => output.split(" "))
  .filter((digit) => [2, 3, 4, 7].includes(digit.length));
```

## Part 2

If we use the following canonical segment labeling:

```plain
 aaaa
b    c
b    c
 dddd
e    f
e    f
 gggg
```

Then we have the following segment usage for each digit:

{/* cSpell:ignore abcefg acdeg acdfg bcdf abdfg abdefg acf abcdefg abcdfg */}

```ts
const digits = {
  abcefg: "0",
  cf: "1",
  acdeg: "2",
  acdfg: "3",
  bcdf: "4",
  abdfg: "5",
  abdefg: "6",
  acf: "7",
  abcdefg: "8",
  abcdfg: "9",
};
```

We can count the number of times each segment letter appears in all ten digits:

| Segment | Times |
| ------- | ----- |
| `a`     | 8     |
| `b`     | 6     |
| `c`     | 8     |
| `d`     | 7     |
| `e`     | 4     |
| `f`     | 9     |
| `g`     | 7     |

This means that if we count the letters in the 10 scrambled patterns, we can instantly determine `b`, `e`, and `f`, because they have unique counts. We then need to tell `a` from `c` (both appear 8 times), and `d` from `g` (both appear 7 times). We already know the patterns for `1`, `4`, `7`, and `8` from part 1. Subtracting the pattern for `1` from that of `7` gives us `a`. Subtracting the pattern for `1` plus `b` from that of `4` gives us `d`.

Once we have the mapping from scrambled letters to actual segments, we can decode the output values by looking up the output patterns using the `digits` map above.

<Footer frontMatter={frontMatter} />
