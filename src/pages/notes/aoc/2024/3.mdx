---
tags:
  - String manipulation
---

# Mull It Over

This problem pays tribute to [2020 day 2](../2020/2.mdx).

## Part 1

I used a regex to extract all `mul(X,Y)` expressions, as nature intended. The pattern is `mul\((\d{1,3}),(\d{1,3})\)`, which captures two numbers between 1 and 999. Then I can iterate over the matches and extract the captured groups.

```ocaml
let re = Re.Perl.compile (Re.Perl.re {|mul\((\d{1,3}),(\d{1,3})\)|}) in
let matches =
  Re.all re line |> List.map (fun g -> (Re.Group.get g 1, Re.Group.get g 2))
in
let products =
  List.map (fun (a, b) -> int_of_string a * int_of_string b) matches
in
let total = List.fold_left ( + ) 0 products in
Printf.printf "%d\n" total
```

## Part 2

Since the patterns can't nest in each other, this remains a regex matching problem, just with two additional things to match: `do\(\)` and `don't\(\)`.

```ocaml
let re =
  Re.Perl.compile
    (Re.Perl.re {|mul\((\d{1,3}),(\d{1,3})\)|do\(\)|(don't)\(\)|})
in
let matches =
  Re.all re line
  |> List.map (fun g ->
      (Re.Group.get g 0, Re.Group.get_opt g 1, Re.Group.get_opt g 2))
```

Each match can be one of three things: `("mul(X,Y)", Some X, Some Y)`, `("do()", None, None)`, or `("don't()", None, None)`. We can iterate over the matches and keep track of whether the state is enabled. Since we are folding anyway, I moved the multiplication and addition into the fold as well to avoid extra mapping and summing steps.

```ocaml
let _, total =
  List.fold_left
    (fun (cur_st, res) (s, a, b) ->
      match s with
      | "do()" -> (true, res)
      | "don't()" -> (false, res)
      | _ -> begin
          match (a, b) with
          | Some a, Some b ->
              if cur_st then
                (cur_st, (int_of_string a * int_of_string b) + res)
              else (cur_st, res)
          | _ -> (cur_st, res)
        end)
    (true, 0) matches
```
