---
description: "Advent of Code 2022 - Day 2: Rock Paper Scissors. Written in Haskell."
tags:
  - Brute force
year: 2022
day: 2
---

# AoC 2022 D2: Rock Paper Scissors

import { FrontMatter, Footer } from "../_components";

<FrontMatter frontMatter={frontMatter} />

## Part 1

Just compute the score for each round based on the given rules.

```hs
winScore :: (Char, Char) -> Int
winScore game = case find (\(opp, self, _) -> (opp, self) == game) outcomes of
  (Just (_, _, score)) -> score
  Nothing -> 0

shapeScore :: Char -> Int
shapeScore 'X' = 1
shapeScore 'Y' = 2
shapeScore _ = 3

score :: (Char, Char) -> Int
score game = winScore game + shapeScore (snd game)
```

`outcomes` records all possible outcomes of the game:

```hs
outcomes :: [(Char, Char, Int)]
outcomes =
  [ ('A', 'X', 3),
    ('B', 'X', 0),
    ('C', 'X', 6),
    ('A', 'Y', 6),
    ('B', 'Y', 3),
    ('C', 'Y', 0),
    ('A', 'Z', 0),
    ('B', 'Z', 6),
    ('C', 'Z', 3)
  ]
```

## Part 2

I want to keep the same `score` function from part 1, so instead of `sumMap score games`, I use `sumMap (\g -> score (fst g, shape g)) games`, where `shape` computes the shape I need to play based on the desired outcome:

```hs
shape :: (Char, Char) -> Char
shape game = case find (\(opp, _, score) -> (opp, scoreToOutcome score) == game) outcomes of
  (Just (_, self, _)) -> self
  Nothing -> 'X'
```

<Footer frontMatter={frontMatter} />
